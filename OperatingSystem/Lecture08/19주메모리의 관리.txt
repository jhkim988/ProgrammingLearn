Process: 실행 중인 프로그램
실행 중: instruction의 집합이 메모리에 올라가 있다는 의미
메모리: array of bytes와 메모리 주소
CPU: instruction을 fetch 한다.
instruction: 메모리에 load, store

메모리에 어떻게 프로세스를 저장하고, 관리할 것인가?

base register, limit register 를 이용하여 제어한다.
Operating System, Process1, Process2, Process3 가 메모리에 올라가 있다면,
Process_i 자신에게 허용된 메모리 범위에만 접근 가능해야한다.(Shared Memory가 아닌 이상...)
base register, limit register를 설정하여 [base, base + limit) 사이의 메모리 주소만 허용한다.
-> 허용되지 않은 메모리 접근: Segment Fault

Protection of Memory Space: [base, base + limit) 범위인지 체크

Address Binding:
프로그램마다 메모리 주소를 다루는 방식이 다르다.
소스코드에서는 compiler 가 메모리 주소를 다룬다.
(int a = 10; a의 주소는 컴파일러가 정한다.)
compiler 가 만든 exe 파일도 binary executable 파일로 disk 에 저장돼 있는 것이다.
이 파일을 메모리에 올리면 프로세스가 된다.
메모리의 어느 위치에 로딩될지는 OS 커널이 결정한다.

컴파일러: symbolic address(소스코드) -> relocatable address(오브젝트)
링커, 로더: relocatable address -> absolute address

logical address: address generated by CPU
physical address: logical address와 관계가 없다.

logical address space, physical address space 분리가 필요하다.
: MMU(Memory management unit) 소프트웨어로 할 수 없고 하드웨어에서 처리해야한다.
MMU를 거쳐 logical address를 physical address로 바꾼다.
relocation register: a base register in MMU
ex)
메모리에 프로세스가 0x14000부터 시작한다.
변수 a의 값이 0x14346에 저장돼 있다 (logical address: 0x346, physical address: 0x14346)
a에 접근하기 위해 CPU가 logical address 346에 접근하면
MMU가 reloacation register를 이용하여 실제 메모리 주소인 0x14346에 접근한다.

Dynamic loading: 파일 전체를 메모리에 올려야 하나? NO
Dynamic loading을 이용하여, 메모리 주소 공간을 효율적으로 사용한다.
모든 루틴을 한꺼번에 로딩할 필요가 없고 필요할 때만 호출한다.
reloatable linking loader가 필요한 루틴을 호출할 때 address table에 반영하면 된다.

Dynamic Linking and Shared libraries
DLLs(Dynamically Linked Libraries): 유저 프로그램이 실행되는 중에 링킹되는 시스템 라이브러리
Static Linking: 시스템 라이브러리가 다른 오브젝트 모듈처럼 다뤄지고, 로더에 의해 바이너리 프로그램 코드에 링킹된다.
Dynamic Linking: 링킹을 실행까지 미루고, 실행하는 중에 dll 파일에 접근하여 링킹한다.

Contiguous Memory Allocation:
프로세스에 메모리를 할당하는 방법: 유저 프로세스를 통째로 로딩(연속 메모리 할당, Contiguous Memory Allocation)
single section of memory
Memory Protection: relocation register와 limit register를 이용하여 간단히 처리할 수 있다.

프로세스들의 크기는 모두 다르다.
메모리 영역이 Variable Partition
어떤 프로세스를 어떻게 할당할 것인지가 문제가 된다. hole이 생기기 때문

Dynamic Storage Allocation:
size n의 request를 free hole에 어떻게 할당해야할까?
1. First-Fit: 넣을 수 있는 첫 번째 hole에 넣는다.
2. Best-Fit: 넣을 수 있는 가장 작은 hole에 넣는다.
3. Worst-Fit: 가장 큰 hole에 넣는다.

Fragmentation(단편화)
external fragmentation(외부 단편화): 남은 자투리 hole들이 많아진다.
internal fragmentation(내부 단편화): 메모리를 일정한 크기로 나눠 각 조각 묶음(프레임)을 할당했을 때 프레임 안에 남는 자투리 공간
연속할당을 하면 외부 단편화, paging을 하면 내부 단편화가 생긴다.

Segmentation
: paging처럼 같은 크기로 나누지 않고, 타입별로 나눈다.(subroutine, stack, main program, ... 등)
연속할당에서보다 나누는 데에서 장점이 있지만 variable size이기 때문에 단편화 문제가 생긴다.