뮤텍스와 세마포어:
- 편하고 효율적으로 동기화를 할 수 있다.
- 타이밍 에러가 발생할 수 있다.(항상 발생하지도 않고, 발견하기 어렵다.)

- Binary Semaphore 에서 signal과 wait의 순서를 지키지 않으면
- 임계영역에 동시에 두 프로세스가 들어갈 수 있다.
- wait()를 두 번 하거나, signal()만 두 번 하는 등...

모니터: 에러가 적게 발생한다.
- 공유 데이터, 초기화 함수, 동기화 되야하는 함수를 갖는 자료 구조
- 추가적인 변수가 필요하다. conditional variables
- condition type을 만들고, condition variable에 각각 wait()와 signal()을 걸 수 있도록 한다.

Java: monitor lock 제공
- synchronized keyword:
임계영역 코드블럭을 선언한다. 모니터 락을 얻어야 진입가능하다.
모니터락을 가진 객체 인스턴스를 지정할 수 있다.
메서드에 synchronized 키워드를 붙이면 메서드 전체를 임계영역으로 설정한다. - 모니터락을 가진 인스턴스는 this
- wait(), notify()
java.lang.Object에 선언된 메서드, 모든 객체가 갖고 있다.
어떤 스레드가 어떤 객체의 wait() 메서드를 호출하면 해당 객체의 모니터락을 얻기 위해 대기상태로 진입한다.
어떤 스레드가 어떤 객체의 notify() 메서드를 호출하면 해당 객체 모니터에 대기중인 스레드를 하나 깨운다.

Liveness:
- Mutex와 데드락 해결

데드락:  두 개 이상의 프로세스가 영원히 기다리는 현상
우선순위 역전: 높은 우선순위를 가진 프로세스가 낮은 우선순위를 가진 프로세스를 기다리는 현상