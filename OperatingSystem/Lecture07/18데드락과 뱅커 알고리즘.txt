Dead Lock Prevention: 어렵고 단점이 많다.
Dead Lock Avoidance:
- 시스템에 request가 오면, 대기하면서 실행됐을 때 발생할 수 있는 future dead lock 고려한다.
- resource가 어떻게 요청되는지 알아야한다.
- Priori Information을 이용하여 Dead lock state에 진입하는 것을 아예 피한다.

미리 알아야 할 정보:
maximum number: 스레드가 요구할 최대의 리소스 개수
number of available/allocated resource
maximum demands

safe state
- 시스템이 데드락을 피하면서 각 스레드에 자원을 할당할 수 있는 상태
- 그러한 스레드 실행 순서가 존재(그 스레드 열을 safe sequence라고 한다.)

unsafe 상태라고 해서 dead lock이 발생하는 것은 아니다.
RAG에서 사이클이 있어도 데드락이 발생하지 않을 수도 있는 것과 같다.

avoidance algorithm: 시스템을 계속 safe state에 머물게 한다.
초기 상태는 safe state다.(Hold Wait 조건에 의해)

시스템이 한 개의 instance만을 가질 때:
Claim Edge: Ti -> Rj, 스레드 Ti가 리소스 Rj를 요청할 예정
Claim Edge를 통해 cycle detection을 해서, cycle이 존재하지 않으면 실행을 허가한다.
cycle이 발생한다면 대기한다.

RAG는 시스템이 여러 개의 instance를 갖고 있으면 적용하기 어렵다.
- 뱅커 알고리즘을 이용한다.

n: the number of threads
m: the number of resource
Available: available resource 타입의 개수를 갖고 있는 벡터
Max: 각각의 thread의 최대 수요를 나타내는 행렬
Allocation: 현재 할당된 resource의 개수를 나타내는 행렬
Need: 각각의 thread에 대해 앞으로 요청할 resource를 나타내는 행렬

Available[j] = k; resource Rj의 k개 instance가 available 하다. 
Max[i][j] = k; thread Ti가 resource Rj의 인스턴스를 많아야 k개 요청한다.
Allocation[i][j] = k; thread Ti가 resource Rj의 인스턴스를 k개 점유하고 있다.
Need[i][j] = k; thread Ti가 resource Rj의 인스턴스를 (앞으로) k개 더 필요로 한다.

Safety Algorithm:
ex)
5 threads T = {T0, T1, T2, T3, T4}
3 resource types  R = {A, B, C}
A = 10, B = 5, C = 7 (인스턴스 개수)
Need[i][j] = MAX[i][j] - alloc[i][j]
    alloc MAX Avail Need
    ABC   ABC ABC   ABC
T0: 010   753 332   743
T1: 200   322       122
T2: 302   902       600
T3: 211   222       011
T4: 002   433       431
sum:725

Sequence: <T1 T3 T4 T0 T2>

(1) work, finish vector initialize
work = (3, 3, 2) (available)
finish = (false, false, false, false, false) (Ti: false)
(2) For finish = false && for all i, Need[i] <= work[i]
(3) work = work + alloc, finish[i] = true
(4) all finish[i] are true -> safe state

int numTrue = 0;
int numTrue = 0;
while (true) {
  nextT: for (int i = 0; i < numT; i++) {
    if (finish[i]) continue;
    for (int j = 0; j < numR; j++) {
      if (need[i][j] > work[j]) continue nextT;
    }
    for (int j = 0; j < numR; j++) {
      work[j] += alloc[i][j];
    }
    finish[i] = true;
    numTrue++;
    System.out.println("Safe seq: " + i);
  }
  if (numTrue >= numT) break;
}

new request:
T1 request, request = (1, 0, 2)
decide grant or not
(1) request <= Need[1] (1,2,2)
(2) request <= available (3,3,2)
alloc[1] = alloc[1] + request[1] = (3,0,2)
need[1] = max[1] - alloc[1] = (0,2,0)
available = available - request = (2,3,0)

-> safety algorithm again...