Dead Lock Prevention: 어렵고 단점이 많다.
Dead Lock Avoidance:
- 시스템에 request가 오면, 대기하면서 실행됐을 때 발생할 수 있는 future dead lock 고려한다.
- resource가 어떻게 요청되는지 알아야한다.
- Priori Information을 이용하여 Dead lock state에 진입하는 것을 아예 피한다.

미리 알아야 할 정보:
maximum number: 스레드가 요구할 최대의 리소스 개수
number of available/allocated resource
maximum demands

safe state
- 시스템이 데드락을 피하면서 각 스레드에 자원을 할당할 수 있는 상태
- 그러한 스레드 실행 순서가 존재(그 스레드 열을 safe sequence라고 한다.)

unsafe 상태라고 해서 dead lock이 발생하는 것은 아니다.
RAG에서 사이클이 있어도 데드락이 발생하지 않을 수도 있는 것과 같다.

avoidance algorithm: 시스템을 계속 safe state에 머물게 한다.
초기 상태는 safe state다.(Hold Wait 조건에 의해)

시스템이 한 개의 instance만을 가질 때:
Claim Edge: Ti -> Rj, 스레드 Ti가 리소스 Rj를 요청할 예정
Claim Edge를 통해 cycle detection을 해서, cycle이 존재하지 않으면 실행을 허가한다.
cycle이 발생한다면 대기한다.

RAG는 시스템이 여러 개의 instance를 갖고 있으면 적용하기 어렵다.
- 뱅커 알고리즘을 이용한다.

n: the number of threads
m: the number of resource
Available: available resource 타입의 개수를 갖고 있는 벡터
Max: 각각의 thread의 최대 수요를 나타내는 행렬
Allocation: 현재 할당된 resource의 개수를 나타내는 행렬
Need: 각각의 thread에 대해 앞으로 요청할 resource를 나타내는 행렬

Available[j] = k; resource Rj의 k개 instance가 available 하다. 
Max[i][j] = k; thread Ti가 resource Rj의 인스턴스를 많아야 k개 요청한다.
Allocation[i][j] = k; thread Ti가 resource Rj의 인스턴스를 k개 점유하고 있다.
Need[i][j] = k; thread Ti가 resource Rj의 인스턴스를 (앞으로) k개 더 필요로 한다.

Safety Algorithm:
